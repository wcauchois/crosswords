// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Canvas$Crosswords = require("./FFI/Canvas.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function compare(param, param$1) {
  var c = Caml_primitive.caml_int_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    return Caml_primitive.caml_int_compare(param[1], param$1[1]);
  }
}

var IntPairs = /* module */[/* compare */compare];

var PairsMap = $$Map.Make(IntPairs);

var fontFace = "monospace";

var primaryFillColor = "#ffeb3b";

var secondaryFillColor = "#2196f3";

var emptyCluePair = /* record */[
  /* vertical : None */0,
  /* horizontal : None */0
];

function empty(width, height, clues) {
  return /* record */[
          /* width */width,
          /* height */height,
          /* cells */PairsMap[/* empty */0],
          /* clues */List.fold_left((function (acc, c) {
                  var existingPair;
                  try {
                    existingPair = Curry._2(PairsMap[/* find */21], /* tuple */[
                          c[/* x */0],
                          c[/* y */1]
                        ], acc);
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      existingPair = emptyCluePair;
                    } else {
                      throw exn;
                    }
                  }
                  var match = c[/* o */3];
                  var newPair = match !== 0 ? /* record */[
                      /* vertical : Some */[c],
                      /* horizontal */existingPair[/* horizontal */1]
                    ] : /* record */[
                      /* vertical */existingPair[/* vertical */0],
                      /* horizontal : Some */[c]
                    ];
                  return Curry._3(PairsMap[/* add */3], /* tuple */[
                              c[/* x */0],
                              c[/* y */1]
                            ], newPair, acc);
                }), PairsMap[/* empty */0], clues)
        ];
}

function isValidCoord(x, y, b) {
  if (x >= 0 && y >= 0 && x < b[/* width */0]) {
    return +(y < b[/* height */1]);
  } else {
    return /* false */0;
  }
}

function list_of_coords(b) {
  var acc = /* [] */0;
  for(var y = 0 ,y_finish = b[/* height */1]; y <= y_finish; ++y){
    for(var x = 0 ,x_finish = b[/* width */0]; x <= x_finish; ++x){
      acc = /* :: */[
        /* tuple */[
          x,
          y
        ],
        acc
      ];
    }
  }
  return List.rev(acc);
}

function get(x, y, b) {
  try {
    return Curry._2(PairsMap[/* find */21], /* tuple */[
                x,
                y
              ], b[/* cells */2]);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* tuple */[
              /* EmptyCell */0,
              /* Unmodified */2
            ];
    } else {
      throw exn;
    }
  }
}

function getState(x, y, b) {
  return get(x, y, b)[0];
}

function makeModFn(modFn, x, y, value, b) {
  var currentCell = get(x, y, b);
  return /* record */[
          /* width */b[/* width */0],
          /* height */b[/* height */1],
          /* cells */Curry._3(PairsMap[/* add */3], /* tuple */[
                x,
                y
              ], Curry._2(modFn, currentCell, value), b[/* cells */2]),
          /* clues */b[/* clues */3]
        ];
}

function setState(param, param$1, param$2, param$3) {
  return makeModFn((function (param, value) {
                return /* tuple */[
                        value,
                        param[1]
                      ];
              }), param, param$1, param$2, param$3);
}

function setModifier(param, param$1, param$2, param$3) {
  return makeModFn((function (param, value) {
                return /* tuple */[
                        param[0],
                        value
                      ];
              }), param, param$1, param$2, param$3);
}

function draw(b, context) {
  var fontSize = 32.0 * 1.0;
  var roundedFontSize = Math.floor(fontSize) | 0;
  context.font = "" + (String(roundedFontSize) + ("px " + (String(fontFace) + "")));
  context.lineWidth = 1.0;
  var drawHorizRulerAt = function (drawY) {
    return Canvas$Crosswords.Ctx[/* line */3](context, /* tuple */[
                0.0,
                drawY
              ], /* tuple */[
                b[/* width */0] * (32.0 + 1.0),
                drawY
              ]);
  };
  var drawVertRulerAt = function (drawX) {
    return Canvas$Crosswords.Ctx[/* line */3](context, /* tuple */[
                drawX,
                0.0
              ], /* tuple */[
                drawX,
                b[/* height */1] * (32.0 + 1.0)
              ]);
  };
  List.iter((function (f) {
          return Curry._1(f, 0.0);
        }), /* :: */[
        drawHorizRulerAt,
        /* :: */[
          drawVertRulerAt,
          /* [] */0
        ]
      ]);
  for(var y = 0 ,y_finish = b[/* height */1]; y <= y_finish; ++y){
    for(var x = 0 ,x_finish = b[/* width */0]; x <= x_finish; ++x){
      var xFloat = x;
      var yFloat = y;
      var drawX = xFloat * 32.0 + (xFloat - 1.0) * 1.0;
      var drawY = yFloat * 32.0 + (yFloat - 1.0) * 1.0;
      drawHorizRulerAt(drawY);
      drawVertRulerAt(drawX);
      var match = get(x, y, b);
      var state = match[0];
      var maybeFillColor;
      switch (match[1]) {
        case 0 : 
            maybeFillColor = /* Some */[primaryFillColor];
            break;
        case 1 : 
            maybeFillColor = /* Some */[secondaryFillColor];
            break;
        case 2 : 
            maybeFillColor = /* None */0;
            break;
        
      }
      if (maybeFillColor) {
        context.fillStyle = maybeFillColor[0];
        context.fillRect(drawX, drawY, 32.0, 32.0);
      }
      if (typeof state === "number") {
        if (state !== 0) {
          context.fillStyle = "#000";
          context.fillRect(drawX, drawY, 32.0, 32.0);
        }
        
      } else {
        context.fillStyle = "#000";
        context.fillText($$String.make(1, state[0]), drawX + 8.0, drawY + 32.0 + -4.0);
      }
    }
  }
  return /* () */0;
}

var boardScale = 32.0;

var gutterSize = 1.0;

var fontSizeMod = 1.0;

var fontOffsX = 8.0;

var fontOffsY = -4.0;

var Ctx = 0;

exports.IntPairs = IntPairs;
exports.PairsMap = PairsMap;
exports.boardScale = boardScale;
exports.gutterSize = gutterSize;
exports.fontSizeMod = fontSizeMod;
exports.fontOffsX = fontOffsX;
exports.fontOffsY = fontOffsY;
exports.fontFace = fontFace;
exports.primaryFillColor = primaryFillColor;
exports.secondaryFillColor = secondaryFillColor;
exports.emptyCluePair = emptyCluePair;
exports.empty = empty;
exports.isValidCoord = isValidCoord;
exports.list_of_coords = list_of_coords;
exports.get = get;
exports.getState = getState;
exports.makeModFn = makeModFn;
exports.setState = setState;
exports.setModifier = setModifier;
exports.Ctx = Ctx;
exports.draw = draw;
/* PairsMap Not a pure module */
