// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Util$Crosswords = require("./Util.bs.js");
var Board$Crosswords = require("./Board.bs.js");

function flipOrientation(o) {
  if (o !== 0) {
    return /* Horizontal */0;
  } else {
    return /* Vertical */1;
  }
}

function empty(b) {
  var firstFreeCell = List.find((function (param) {
          var match = Board$Crosswords.getState(param[0], param[1], b);
          if (typeof match === "number" && match === 0) {
            return /* true */1;
          } else {
            return /* false */0;
          }
        }), Board$Crosswords.list_of_coords(b));
  return /* record */[
          /* cursor */firstFreeCell,
          /* orientation : Horizontal */0
        ];
}

function direction_of_orientation(o) {
  if (o !== 0) {
    return /* tuple */[
            0,
            1
          ];
  } else {
    return /* tuple */[
            1,
            0
          ];
  }
}

function filledCoords(b, s) {
  var match = s[/* cursor */0];
  var cursorY = match[1];
  var cursorX = match[0];
  var match$1 = direction_of_orientation(s[/* orientation */1]);
  var dirY = match$1[1];
  var dirX = match$1[0];
  var nonCursorPositions = List.flatten(List.map((function (modScalar) {
              return Util$Crosswords.unfold((function (i) {
                            var x = Caml_int32.imul(Caml_int32.imul(dirX, modScalar), i) + cursorX | 0;
                            var y = Caml_int32.imul(Caml_int32.imul(dirY, modScalar), i) + cursorY | 0;
                            if (Board$Crosswords.isValidCoord(x, y, b)) {
                              var match = Board$Crosswords.get(x, y, b);
                              var match$1 = match[0];
                              var exit = 0;
                              if (typeof match$1 === "number") {
                                if (match$1 !== 0) {
                                  return /* None */0;
                                } else {
                                  exit = 1;
                                }
                              } else {
                                exit = 1;
                              }
                              if (exit === 1) {
                                return /* Some */[/* tuple */[
                                          /* tuple */[
                                            x,
                                            y
                                          ],
                                          i + 1 | 0
                                        ]];
                              }
                              
                            } else {
                              return /* None */0;
                            }
                          }), 1);
            }), /* :: */[
            -1,
            /* :: */[
              1,
              /* [] */0
            ]
          ]));
  return /* :: */[
          s[/* cursor */0],
          nonCursorPositions
        ];
}

function applyModifiers(b, s) {
  var match = s[/* cursor */0];
  var b$1 = Board$Crosswords.setModifier(match[0], match[1], /* PrimaryHighlighted */0, b);
  return List.fold_left((function (b, param) {
                return Board$Crosswords.setModifier(param[0], param[1], /* SecondaryHighlighted */1, b);
              }), b$1, List.filter((function (c) {
                      return Caml_obj.caml_notequal(c, s[/* cursor */0]);
                    }))(filledCoords(b$1, s)));
}

exports.flipOrientation = flipOrientation;
exports.empty = empty;
exports.direction_of_orientation = direction_of_orientation;
exports.filledCoords = filledCoords;
exports.applyModifiers = applyModifiers;
/* Board-Crosswords Not a pure module */
