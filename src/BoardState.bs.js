// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Util$Crosswords = require("./Util.bs.js");
var Board$Crosswords = require("./Board.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function flipOrientation(o) {
  if (o !== 0) {
    return /* Horizontal */0;
  } else {
    return /* Vertical */1;
  }
}

function moveCursor(_, _$1, _$2, s) {
  return s;
}

function empty(b) {
  var firstFreeCell = List.find((function (param) {
          var match = Board$Crosswords.getState(param[0], param[1], b);
          if (typeof match === "number" && match === 0) {
            return /* true */1;
          } else {
            return /* false */0;
          }
        }), Board$Crosswords.list_of_coords(b));
  return /* record */[
          /* cursor */firstFreeCell,
          /* orientation : Horizontal */0
        ];
}

function filledCoords(b, s) {
  var match = s[/* cursor */0];
  var cursorY = match[1];
  var cursorX = match[0];
  var match$1 = Util$Crosswords.direction_of_orientation(s[/* orientation */1]);
  var dirY = match$1[1];
  var dirX = match$1[0];
  var nonCursorPositions = List.flatten(List.map((function (modScalar) {
              return Util$Crosswords.unfold((function (i) {
                            var x = Caml_int32.imul(Caml_int32.imul(dirX, modScalar), i) + cursorX | 0;
                            var y = Caml_int32.imul(Caml_int32.imul(dirY, modScalar), i) + cursorY | 0;
                            if (Board$Crosswords.isValidCoord(x, y, b)) {
                              var match = Board$Crosswords.get(x, y, b);
                              var match$1 = match[0];
                              var exit = 0;
                              if (typeof match$1 === "number") {
                                if (match$1 !== 0) {
                                  return /* None */0;
                                } else {
                                  exit = 1;
                                }
                              } else {
                                exit = 1;
                              }
                              if (exit === 1) {
                                return /* Some */[/* tuple */[
                                          /* tuple */[
                                            x,
                                            y
                                          ],
                                          i + 1 | 0
                                        ]];
                              }
                              
                            } else {
                              return /* None */0;
                            }
                          }), 1);
            }), /* :: */[
            -1,
            /* :: */[
              1,
              /* [] */0
            ]
          ]));
  return /* :: */[
          s[/* cursor */0],
          nonCursorPositions
        ];
}

function clueForOrientation(p, o) {
  if (o !== 0) {
    return p[/* vertical */0];
  } else {
    return p[/* horizontal */1];
  }
}

function currentClue(b, s) {
  var clueCoordOpt;
  try {
    clueCoordOpt = /* Some */[List.find((function (coord) {
              var exit = 0;
              var pair;
              try {
                pair = Curry._2(Board$Crosswords.PairsMap[/* find */21], coord, b[/* clues */3]);
                exit = 1;
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return /* false */0;
                } else {
                  throw exn;
                }
              }
              if (exit === 1) {
                return Js_option.isSome(clueForOrientation(pair, s[/* orientation */1]));
              }
              
            }), filledCoords(b, s))];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      clueCoordOpt = /* None */0;
    } else {
      throw exn;
    }
  }
  return Util$Crosswords.flattenOption(Js_option.map((function (clueCoord) {
                    return clueForOrientation(Curry._2(Board$Crosswords.PairsMap[/* find */21], clueCoord, b[/* clues */3]), s[/* orientation */1]);
                  }), clueCoordOpt));
}

function applyModifiers(b, s) {
  var match = s[/* cursor */0];
  var b$1 = Board$Crosswords.setModifier(match[0], match[1], /* PrimaryHighlighted */0, b);
  return List.fold_left((function (b, param) {
                return Board$Crosswords.setModifier(param[0], param[1], /* SecondaryHighlighted */1, b);
              }), b$1, List.filter((function (c) {
                      return Caml_obj.caml_notequal(c, s[/* cursor */0]);
                    }))(filledCoords(b$1, s)));
}

var PairsMap = 0;

exports.flipOrientation = flipOrientation;
exports.moveCursor = moveCursor;
exports.empty = empty;
exports.filledCoords = filledCoords;
exports.PairsMap = PairsMap;
exports.clueForOrientation = clueForOrientation;
exports.currentClue = currentClue;
exports.applyModifiers = applyModifiers;
/* Board-Crosswords Not a pure module */
