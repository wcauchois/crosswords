// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Dom$Crosswords = require("./FFI/Dom.bs.js");
var Util$Crosswords = require("./Util.bs.js");
var Bacon$Crosswords = require("./FFI/Bacon.bs.js");
var Board$Crosswords = require("./Board.bs.js");
var BoardState$Crosswords = require("./BoardState.bs.js");

var canvas = Curry._1(Dom$Crosswords.getById, "c");

var context = canvas.getContext("2d");

var clues = /* :: */[
  /* tuple */[
    1,
    0,
    "Thingy that you should fill in"
  ],
  /* [] */0
];

var b = Board$Crosswords.setState(5, 7, /* Blocked */1, Board$Crosswords.setState(5, 6, /* Blocked */1, Board$Crosswords.setState(5, 5, /* Blocked */1, Board$Crosswords.setState(5, 0, /* Blocked */1, Board$Crosswords.setState(4, 0, /* Blocked */1, Board$Crosswords.setState(0, 0, /* Blocked */1, Board$Crosswords.empty(10, 10, clues)))))));

var board = List.fold_left((function (b, param) {
        return Board$Crosswords.setState(1 + param[0] | 0, 2, /* Full */[param[1]], b);
      }), b, List.mapi((function (i, c) {
            return /* tuple */[
                    i,
                    c
                  ];
          }), Util$Crosswords.explodeString("hello")));

Board$Crosswords.draw(board, context);

var keyObs = Bacon$Crosswords.capturingKeyboardObservable((function ($$event) {
        var match = $$event.key;
        switch (match) {
          case " " : 
              return /* Some */[/* SpaceBar */4];
          case "ArrowDown" : 
              return /* Some */[/* Down */3];
          case "ArrowLeft" : 
              return /* Some */[/* Left */0];
          case "ArrowRight" : 
              return /* Some */[/* Right */1];
          case "ArrowUp" : 
              return /* Some */[/* Up */2];
          default:
            return /* None */0;
        }
      }));

var stateObs = keyObs.scan(BoardState$Crosswords.empty(board), (function (s, key) {
        var match = s[/* cursor */0];
        var oldY = match[1];
        var oldX = match[0];
        var newCursor;
        switch (key) {
          case 0 : 
              newCursor = /* tuple */[
                oldX - 1 | 0,
                oldY + 0 | 0
              ];
              break;
          case 1 : 
              newCursor = /* tuple */[
                oldX + 1 | 0,
                oldY + 0 | 0
              ];
              break;
          case 2 : 
              newCursor = /* tuple */[
                oldX + 0 | 0,
                oldY - 1 | 0
              ];
              break;
          case 3 : 
              newCursor = /* tuple */[
                oldX + 0 | 0,
                oldY + 1 | 0
              ];
              break;
          case 4 : 
              newCursor = /* tuple */[
                oldX,
                oldY
              ];
              break;
          
        }
        var newOrientation = key === /* SpaceBar */4 ? BoardState$Crosswords.flipOrientation(s[/* orientation */1]) : s[/* orientation */1];
        return /* record */[
                /* cursor */newCursor,
                /* orientation */newOrientation
              ];
      }));

var initBoardState = BoardState$Crosswords.empty(board);

var boardObs = stateObs.map((function (state) {
        return BoardState$Crosswords.applyModifiers(board, state);
      }));

boardObs.onValue((function (b) {
        context.clearRect(0.0, 0.0, 480.0, 480.0);
        return Board$Crosswords.draw(b, context);
      }));

var Ctx = 0;

var Observable = 0;

var KeyboardEvent = 0;

exports.canvas = canvas;
exports.context = context;
exports.Ctx = Ctx;
exports.clues = clues;
exports.board = board;
exports.Observable = Observable;
exports.KeyboardEvent = KeyboardEvent;
exports.keyObs = keyObs;
exports.stateObs = stateObs;
exports.initBoardState = initBoardState;
exports.boardObs = boardObs;
/* canvas Not a pure module */
