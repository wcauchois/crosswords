// Generated by BUCKLESCRIPT VERSION 2.2.0, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Gen$Crosswords = require("../src/Gen.bs.js");

var exampleList = /* :: */[
  1,
  /* :: */[
    2,
    /* :: */[
      3,
      /* [] */0
    ]
  ]
];

describe("ofList", (function () {
        var gen = Gen$Crosswords.ofList(exampleList);
        return Jest.testAll("generator", List.append(List.map((function (i) {
                              return /* Some */[i];
                            }), exampleList), /* :: */[
                        /* None */0,
                        /* [] */0
                      ]), (function (iOpt) {
                      return Jest.Expect[/* toEqual */12](iOpt, Jest.Expect[/* expect */0](Curry._1(gen, /* () */0)));
                    }));
      }));

describe("collect", (function () {
        var gen = Gen$Crosswords.ofList(exampleList);
        return Jest.test("roundTrip", (function () {
                      return Jest.Expect[/* toEqual */12](exampleList, Jest.Expect[/* expect */0](Gen$Crosswords.collect(gen)));
                    }));
      }));

describe("range", (function () {
        Jest.test("simple", (function () {
                return Jest.Expect[/* toEqual */12](/* :: */[
                            0,
                            /* :: */[
                              1,
                              /* :: */[
                                2,
                                /* [] */0
                              ]
                            ]
                          ], Jest.Expect[/* expect */0](Gen$Crosswords.collect(Gen$Crosswords.range(0, 3))));
              }));
        Jest.test("step", (function () {
                return Jest.Expect[/* toEqual */12](/* :: */[
                            0,
                            /* :: */[
                              2,
                              /* :: */[
                                4,
                                /* [] */0
                              ]
                            ]
                          ], Jest.Expect[/* expect */0](Gen$Crosswords.collect(Gen$Crosswords.rangeStep(0, 5, 2))));
              }));
        return Jest.test("negativeStep", (function () {
                      return Jest.Expect[/* toEqual */12](/* :: */[
                                  3,
                                  /* :: */[
                                    2,
                                    /* :: */[
                                      1,
                                      /* [] */0
                                    ]
                                  ]
                                ], Jest.Expect[/* expect */0](Gen$Crosswords.collect(Gen$Crosswords.rangeStep(3, 0, -1))));
                    }));
      }));

describe("cartesian", (function () {
        Jest.test("simple", (function () {
                return Jest.Expect[/* toEqual */12](/* :: */[
                            /* tuple */[
                              1,
                              3
                            ],
                            /* :: */[
                              /* tuple */[
                                1,
                                4
                              ],
                              /* :: */[
                                /* tuple */[
                                  2,
                                  3
                                ],
                                /* :: */[
                                  /* tuple */[
                                    2,
                                    4
                                  ],
                                  /* [] */0
                                ]
                              ]
                            ]
                          ], Jest.Expect[/* expect */0](Gen$Crosswords.collect(Gen$Crosswords.cartesian(Gen$Crosswords.ofList(/* :: */[
                                            1,
                                            /* :: */[
                                              2,
                                              /* [] */0
                                            ]
                                          ]), Gen$Crosswords.ofList(/* :: */[
                                            3,
                                            /* :: */[
                                              4,
                                              /* [] */0
                                            ]
                                          ])))));
              }));
        Jest.test("emptyFirstList", (function () {
                return Jest.Expect[/* toEqual */12](/* [] */0, Jest.Expect[/* expect */0](Gen$Crosswords.collect(Gen$Crosswords.cartesian(Gen$Crosswords.ofList(/* :: */[
                                            1,
                                            /* :: */[
                                              2,
                                              /* [] */0
                                            ]
                                          ]), (function () {
                                          return /* None */0;
                                        })))));
              }));
        return Jest.test("emptySecondList", (function () {
                      return Jest.Expect[/* toEqual */12](/* [] */0, Jest.Expect[/* expect */0](Gen$Crosswords.collect(Gen$Crosswords.cartesian((function () {
                                                return /* None */0;
                                              }), Gen$Crosswords.ofList(/* :: */[
                                                  1,
                                                  /* :: */[
                                                    2,
                                                    /* [] */0
                                                  ]
                                                ])))));
                    }));
      }));

exports.exampleList = exampleList;
/*  Not a pure module */
